---
title: "Multiple Docker Networks"
id: 1238
draftstate: inactive
deleted: false
source: https://success.docker.com/@api/deki/pages/1238/contents
tags:
- tag: "article:tutorial"
---
{% raw %}
<div class="mt-section" id="section_1" mt-section-origin="KBase/Multiple_Docker_Networks">
 <span id="Goal">
 </span>
 <h1 id="0-0">
  Goal
 </h1>
 <p>
  Containers can join multiple networks which allows you to provide fine grained network policy for connectivity and isolation. By default a container will be created with one network attached. If no network is specified then this will be the default docker0 network. After the container has been created more networks can be attached to a container using the
  <code>
   docker network connect
  </code>
  command.
 </p>
</div>
<div class="mt-section" id="section_2" mt-section-origin="KBase/Multiple_Docker_Networks">
 <span id="Steps">
 </span>
 <h1 id="0-1">
  Steps
 </h1>
 <p>
  The following example creates two networks and attach them to the
  <code>
   c1
  </code>
  container. Docker only allows a single network to be specified with the
  <code>
   docker run
  </code>
  command. To connect multiple networks
  <code>
   docker network connect
  </code>
  is used to connect additional networks. If a container needs to be connected to multiple networks before it runs then it is possible to attach networks to a created container that has not started yet. This is done by creating a container with
  <code>
   docker create
  </code>
  , attaching the networks with
  <code>
   docker network connect
  </code>
  , and then running the created container with docker start. This will ensure that the container has all of the required network attachments on startup.
 </p>
 <div class="mt-section" id="section_3" mt-section-origin="KBase/Multiple_Docker_Networks">
  <span id="Step_1">
  </span>
  <h2 id="1-0">
   Step 1
  </h2>
  <p>
   Create the networks that you would like to attach to your container.
  </p>
  <pre>
<code>$ docker network create bluenet
$ docker network create rednet
</code></pre>
 </div>
 <div class="mt-section" id="section_4" mt-section-origin="KBase/Multiple_Docker_Networks">
  <span id="Step_2a">
  </span>
  <h2 id="1-1">
   Step 2a
  </h2>
  <p>
   Run the container. You can specify an initial network for it to start with. If no network is specified then the container will be attached to the default
   <code>
    docker0
   </code>
   network.
  </p>
  <pre>
<code>docker run -itd --net bluenet --name c1 busybox sh</code></pre>
 </div>
 <div class="mt-section" id="section_5" mt-section-origin="KBase/Multiple_Docker_Networks">
  <span id="Step_2b">
  </span>
  <h2 id="1-2">
   Step 2b
  </h2>
  <p>
   There are some cases where it may be desirable for a container to not start until it has all the correct networks attached - for instance, an application that uses the networks immediately on startup.
  </p>
  <p>
   In this case it is best to create the container with
   <code>
    docker create
   </code>
   , attach the networks, and then start the container with
   <code>
    docker start
   </code>
   .
  </p>
  <p>
   Create the container with its initial network.
  </p>
  <pre>
<code>docker create -it --net bluenet --name c1 busybox sh</code></pre>
  <p>
   You can see that the container is in a
   <code>
    Created
   </code>
   but not running state.
  </p>
  <pre>
<code>$ docker ps -a
CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS                  PORTS               NAMES
e616fc9965f6        busybox                "sh"                     16 seconds ago      Created                                     c1
</code></pre>
 </div>
 <div class="mt-section" id="section_6" mt-section-origin="KBase/Multiple_Docker_Networks">
  <span id="Step_3">
  </span>
  <h2 id="1-3">
   Step 3
  </h2>
  <p>
   Attach the remaining networks.
  </p>
  <p>
   <code>
    $ docker network connect rednet c1
   </code>
  </p>
 </div>
 <div class="mt-section" id="section_7" mt-section-origin="KBase/Multiple_Docker_Networks">
  <span id="Step_3b">
  </span>
  <h2 id="1-4">
   Step 3b
  </h2>
  <p>
   If the container has not been started yet then start the container.
  </p>
  <pre>
<code>docker start c1</code></pre>
 </div>
 <div class="mt-section" id="section_8" mt-section-origin="KBase/Multiple_Docker_Networks">
  <span id="Step_4">
  </span>
  <h2 id="1-5">
   Step 4
  </h2>
  <p>
   Now verify that the running container is connected to multiple networks.
  </p>
  <pre>
<code>$ docker exec -it c1 sh

/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:1D:00:02
          inet addr:172.29.0.2  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe1d:2/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:16 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:1296 (1.2 KiB)  TX bytes:648 (648.0 B)

eth1      Link encap:Ethernet  HWaddr 02:42:AC:1E:00:02
          inet addr:172.30.0.2  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe1e:2/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:16 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:1296 (1.2 KiB)  TX bytes:648 (648.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # ip route
default via 172.29.0.1 dev eth0
172.29.0.0/16 dev eth0  src 172.29.0.2
172.30.0.0/16 dev eth1  src 172.30.0.2  
</code></pre>
 </div>
</div>
<div class="mt-section" id="section_9" mt-section-origin="KBase/Multiple_Docker_Networks">
 <span id="Results">
 </span>
 <h1 id="0-2">
  Results
 </h1>
 <p>
  You can see from this example thatÂ every new network attachment Docker automatically creates a new
  <code>
   eth
  </code>
  interface inside the container. Networks can be detached from containers with
  <code>
   docker network disconnect
  </code>
  and the respective
  <code>
   eth
  </code>
  inside the container will be removed.
 </p>
</div>
{% endraw %}
